// To analyze the performance of an algorithm, we use Big O Notation
// Big O Notation can give us a high level understanding of the time or space complexity of an algorithm
// big o notation is a way to formalize fuzzy counting
// it allows us to talk formally about how the runtime of an algorithm grows as the inputs grow
// Example - O(1), O(n), O(n*n)

// Time Complexity
// it allows us to talk formally about how the runtime of an algorithm grows as the inputs grow
// Big O Shorthands
// Arithmetic operations are constant
// Variable assignment is constant
// Accessing elements in an array (by index) or object (by key) is constant
// In a loop, the the complexity is the length of the loop times the complexity of whatever happens inside of the loop

// Big O Chart
// O(n!)
// O(2^n)
// O(n^2)
// O(n log n)
// O(n)
// O(log n) or O(1)

// Space Complexity
// how much additional memory do we need to allocate in order to run the code in our algorithm?
// Rules of Thumb
// Most primitives (booleans, numbers, undefined, null) are constant space
// Strings require O(n) space (where n is the string length)
// Reference types are generally O( n), where n is the length (for arrays) or the number of keys (for objects)
// The time or space complexity (as measured by Big O) depends only on the algorithm, not the hardware used to run the algorithm

// Performance Tracker Tool
// https://rithmschool.github.io/function-timer-demo/
